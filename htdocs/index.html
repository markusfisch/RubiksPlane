<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width"/>
<title>Shapeshifting Castle</title>
<style>

html,
body
{
	margin: 0; padding: 0;
	overflow: hidden;
}

canvas
{
	position: fixed;
	left: 0; right: 0;
	top: 0; bottom: 0;
}

</style>
</head>
<body>
<canvas id="Canvas">Sorry, your browser cannot render this content.</canvas>
<script id="VertexShader" type="x-shader/x-vertex">

attribute vec2 vertexPosition;
attribute vec2 texturePosition;

uniform mat3 perspective;
uniform mat3 transformation;

varying vec2 textureUV;

void main()
{
	gl_Position = vec4(
		perspective*
		transformation*
		vec3( vertexPosition, 1. ), 1. );

	textureUV = texturePosition;
}

</script>
<script id="FragmentShader" type="x-shader/x-fragment">

#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

varying vec2 textureUV;

uniform sampler2D texture;

void main()
{
	gl_FragColor = texture2D( texture, textureUV.st ).rgba;
}

</script>
<script>

"use strict"

var D = document,
	M = Math,
	W = window,
	PERSPECTIVE = "perspective",
	TRANSFORMATION = "transformation",
	TEXTURE = "texture",
	CBL = 1,
	CBLI = 2,
	CBR = 3,
	CBRI = 4,
	CTL = 5,
	CTLI = 6,
	CTR = 7,
	CTRI = 8,
	IC2B = 9,
	IC2L = 10,
	IC2R = 11,
	IC2T = 12,
	IC3BL = 13,
	IC3BR = 14,
	IC3TL = 15,
	IC3TR = 16,
	IC4 = 17,
	ICBL = 18,
	ICBR = 19,
	ICTL = 20,
	ICTR = 21,
	PH = 22,
	PV = 23,
	UB = 24,
	UL = 25,
	UR = 26,
	UT = 27,
	WB = 28,
	WBIC2T = 29,
	WBICTL = 30,
	WBICTR = 31,
	WIZARD = 32,
	WIZARD_CAST = 33,
	WL = 34,
	WLIC2R = 35,
	WLICBR = 36,
	WLICTR = 37,
	WR = 38,
	WRIC2L = 39,
	WRICBL = 40,
	WRICTL = 41,
	WT = 42,
	WTIC2B = 43,
	WTICBL = 44,
	WTICBR = 45,
	FLOOR = 46,
	atlas,
	sprites = [],
	canvas,
	gl,
	vertexPositionBuffer,
	vertexPositionLoc,
	texturePositionBuffer,
	texturePositionLoc,
	perspective,
	transformation,
	texture,
	program,
	width,
	height,
	halfWidth,
	halfHeight,
	yMax,
	scaleFactor,
	last,
	now,
	factor,
	keysDown = [],
	pointersLength = 0,
	pointersX = [],
	pointersY = [],
	tileSize,
	halfTileSize,
	horizonX,
	horizonY,
	map = [],
	mapLength,
	mapX,
	mapY,
	mapCols,
	mapRows,
	displaceY,
	displaceSpeed,
	lastPointerX,
	lastPointerY,
	shiftThresholdX,
	shiftThresholdY,
	dragging = false,
	shifting = false,
	shiftCol,
	shiftRow,
	shiftDirection,
	target,
	targetLength,
	targetCols,
	targetX,
	targetY,
	targetTileSize,
	targetFactor,
	entityLength = 0,
	entities = [],
	moves = 0,
	level = 0,
	levels = [
		function()
		{
			initMap( 2, 2,
			[
				UL, 0,
				PH, UR,
			] )

			initTarget( 3,
			[
				UL, PH, UR,
			] )
		},
		function()
		{
			initMap( 3, 2,
			[
				CBL, WL, CTR,
				CTL, WR, CBR,
			] )

			initTarget( 2,
			[
				CTL, CTR,
				WL, WR,
				CBL, CBR
			] )
		},
		function()
		{
			initMap( 5, 5,
			[
				0, 0, CBRI, 0, 0,
				0, PV, WLIC2R, PH, 0,
				CTLI, PH, WRIC2L, PV, CTRI,
				0, PV, PV, PH, 0,
				0, 0, CBLI, 0, 0,
			] )

			initTarget( 3,
			[
				CTLI, PH, CTRI,
				PV, 0, PV,
				WLIC2R, PH, WRIC2L,
				PV, 0, PV,
				CBLI, PH, CBRI,
			] )
		},
		function()
		{
			initMap( 3, 4,
			[
				CBR, CTR, CTL,
				0, WT, 0,
				CBL, 0, 0,
				0, 0, WB,
			] )

			initTarget( 3,
			[
				CTL, WT, CTR,
				CBL, WB, CBR,
			] )
		},
		function()
		{
			initMap( 3, 3,
			[
				0, 0, UB,
				0, CBR, WLICBR,
				UR, WTICBR, CTL,
			] )

			initTarget( 3,
			[
				CTL, WTICBR, UR,
				WLICBR, CBR, 0,
				UB, 0, 0,
			] )
		},
		/*function()
		{
			initMap( 7, 5,
			[
				0, 2, 1, 1, 2, 1, 1,
				0, 1, 2, 0, 1, 2, 0,
				1, 2, 0, 0, 1, 2, 0,
				0, 2, 2, 0, 1, 2, 0,
				0, 2, 2, 2, 0, 0, 0,
			] )

			initTarget( 5,
			[
				1, 2, 1, 2, 1,
				2, 0, 2, 0, 2,
				1, 2, 1, 2, 1,
				2, 0, 2, 0, 2,
				1, 2, 1, 2, 1,
			] )
		},
		function()
		{
			initMap( 5, 5,
			[
				1, 2, 0, 2, 1,
				2, 1, 0, 1, 2,
				0, 0, 0, 0, 0,
				2, 1, 0, 1, 2,
				1, 2, 0, 2, 1,
			] )

			initTarget( 4,
			[
				1, 1, 2, 2,
				1, 1, 2, 2,
				2, 2, 1, 1,
				2, 2, 1, 1,
			] )
		},
		function()
		{
			initMap( 5, 5,
			[
				1, 0, 0, 0, 2,
				0, 1, 0, 2, 0,
				0, 0, 1, 0, 0,
				0, 2, 0, 1, 0,
				2, 0, 0, 0, 1,
			] )

			initTarget( 3,
			[
				1, 2, 1,
				2, 1, 2,
				1, 2, 1,
			] )
		},
		function()
		{
			initMap( 5, 3,
			[
				1, 2, 1, 2, 1,
				0, 1, 2, 1, 0,
				0, 0, 1, 0, 0,
			] )

			initTarget( 5,
			[
				0, 0, 1, 0, 0,
				0, 1, 2, 1, 0,
				1, 2, 1, 2, 1,
			] )
		},
		function()
		{
			initMap( 5, 5,
			[
				0, 1, 0, 1, 0,
				1, 2, 1, 0, 2,
				2, 1, 2, 1, 0,
				1, 2, 1, 0, 2,
				0, 1, 0, 2, 2,
			] )

			initTarget( 5,
			[
				1, 0, 0, 0, 1,
				2, 1, 0, 1, 2,
				2, 2, 1, 2, 2,
				2, 1, 0, 1, 2,
				1, 0, 0, 0, 1,
			] )
		},
		function()
		{
			initMap( 5, 5,
			[
				1, 0, 1, 0, 1,
				0, 2, 0, 2, 0,
				1, 0, 1, 0, 1,
				0, 2, 0, 2, 0,
				1, 0, 1, 0, 1,
			] )

			initTarget( 5,
			[
				0, 0, 1, 0, 0,
				0, 1, 2, 1, 0,
				1, 2, 1, 2, 1,
				0, 1, 2, 1, 0,
				0, 0, 1, 0, 0,
			] )
		},
		function()
		{
			initMap( 6, 6,
			[
				1, 0, 2, 1, 0, 0,
				0, 1, 0, 0, 2, 0,
				2, 0, 1, 1, 0, 1,
				1, 0, 1, 1, 0, 2,
				0, 2, 0, 0, 1, 0,
				0, 0, 1, 2, 0, 1,
			] )

			initTarget( 4,
			[
				1, 1, 1, 1,
				1, 2, 2, 1,
				0, 2, 2, 0,
				1, 2, 2, 1,
				1, 1, 1, 1,
			] )
		},
		function()
		{
			initMap( 5, 5,
			[
				1, 2, 1, 0, 1,
				2, 0, 2, 0, 2,
				0, 1, 0, 1, 0,
				2, 0, 2, 0, 2,
				1, 0, 1, 2, 1,
			] )

			initTarget( 5,
			[
				1, 0, 1, 0, 1,
				2, 1, 2, 1, 2,
				1, 2, 1, 2, 1,
				2, 0, 2, 0, 2,
			] )
		},*/
	]

function drawSprite( sprite, x, y, wm, hm )
{
	gl.bindBuffer( gl.ARRAY_BUFFER, vertexPositionBuffer )
	gl.vertexAttribPointer(
		vertexPositionLoc,
		2,
		gl.FLOAT,
		gl.FALSE,
		0,
		0 )

	gl.bindBuffer( gl.ARRAY_BUFFER, texturePositionBuffer )
	gl.vertexAttribPointer(
		texturePositionLoc,
		2,
		gl.FLOAT,
		gl.FALSE,
		0,
		sprite.index << 5 )

	gl.uniformMatrix3fv(
		program.uniforms[PERSPECTIVE],
		gl.FALSE,
		perspective )

	transformation[0] =
		transformation[8] = sprite.w*(wm || 1)
	transformation[4] = sprite.h*(hm || 1)

	transformation[6] = x
	transformation[7] = y

	gl.uniformMatrix3fv(
		program.uniforms[TRANSFORMATION],
		gl.FALSE,
		transformation )

	gl.activeTexture( gl.TEXTURE0 )
	gl.bindTexture( gl.TEXTURE_2D, texture )
	gl.uniform1i( program.uniforms[TEXTURE], 0 )

	gl.drawArrays( gl.TRIANGLE_STRIP, 0, 4 )
}

function drawTarget()
{
	for( var offset = 0, y = targetY;
		offset < targetLength;
		y -= targetTileSize )
		for( var col = 0, x = targetX;
			col < targetCols;
			++col, ++offset, x += targetTileSize )
		{
			var id = target[offset]

			if( id < 1 )
				continue

			drawSprite(
				sprites[id],
				x,
				y,
				targetFactor,
				targetFactor )
		}
}

function drawEntities()
{
	for( var n = entityLength; n--; )
	{
		var entity = entities[n]

		if( entity.tile < 0 )
			continue

		var tile = map[entity.tile]

		drawSprite(
			entity.sprite,
			mapX+tile.x,
			mapY+tile.y )
	}
}

function drawMap()
{
	var offsetY = mapY+displaceY

	if( displaceY > 0 )
		displaceY = M.max( 0, displaceY-displaceSpeed*factor );

	for( var n = mapLength; n--; )
	{
		var tile = map[n],
			x = tile.x+mapX,
			y = tile.y+offsetY

		if( x < -horizonX ||
			x > horizonX ||
			y < -horizonY ||
			y > horizonY )
			continue

		drawSprite( tile.sprite, x, y )
	}
}

function draw()
{
	gl.clear(
		gl.COLOR_BUFFER_BIT |
		gl.DEPTH_BUFFER_BIT )

	gl.useProgram( program )

	drawMap()
	drawEntities()
	drawTarget()
}

function run()
{
	requestAnimationFrame( run )

	now = Date.now()
	factor = (now-last)/16
	last = now

	draw()
}

function loadLevel()
{
	displaceY = 1
	levels[level % levels.length]()
}

function checkMap()
{
	var colMin = 999999999,
		rowMin = 999999999

	for( var n = mapLength; n--; )
	{
		var tile = map[n]

		if( tile.id < 1 )
			continue

		colMin = M.min( tile.col, colMin )
		rowMin = M.min( tile.row, rowMin )
	}

	for( var n = mapLength; n--; )
	{
		var tile = map[n]

		if( tile.id < 1 )
			continue

		var col = tile.col-colMin

		if( col >= targetCols )
			return

		var offset = (tile.row-rowMin)*targetCols+col

		if( offset >= targetLength ||
			target[offset] != tile.id )
			return
	}

	if( ++level >= levels.length )
	{
		D.write( "Beat in "+moves+" moves." )
		return
	}

	loadLevel()
}

function predictableRound( value )
{
	var f = M.abs( value-M.floor( value ) )

	if( f > .4 && f < .6 )
		value += .1

	return M.round( value )
}

function lockCol( col )
{
	var change = false

	for( var n = mapLength; n--; )
	{
		var tile = map[n]

		if( tile.col == col )
		{
			var old = tile.row,
				row = predictableRound( -tile.y/tileSize )

			if( old != row )
				change = true

			tile.row = row
			tile.y = row*-tileSize
		}
	}

	change && ++moves
}

function lockRow( row )
{
	var change = false

	for( var n = mapLength; n--; )
	{
		var tile = map[n]

		if( tile.row == row )
		{
			var old = tile.col,
				col = predictableRound( tile.x/tileSize )

			if( old != col )
				change = true

			tile.col = col
			tile.x = col*tileSize
		}
	}

	change && ++moves
}

function shiftColBy( col, shift )
{
	for( var n = mapLength; n--; )
	{
		var tile = map[n]

		if( tile.col == col )
			tile.y += shift
	}
}

function shiftRowBy( row, shift )
{
	for( var n = mapLength; n--; )
	{
		var tile = map[n]

		if( tile.row == row )
			tile.x += shift
	}
}

function tileAt( x, y )
{
	for( var n = mapLength; n--; )
	{
		var tile = map[n],
			dx = x-tile.x,
			dy = y-tile.y

		if( M.abs( dx ) < halfTileSize &&
			M.abs( dy ) < halfTileSize )
			return tile
	}

	return null
}

function stopShift()
{
	if( shifting )
	{
		if( shiftDirection )
			lockRow( shiftRow )
		else
			lockCol( shiftCol )

		checkMap()
	}

	shifting = false
	dragging = false
}

function shift( x, y )
{
	var dx = x-lastPointerX,
		dy = y-lastPointerY

	if( M.abs( dx ) < shiftThresholdX &&
		M.abs( dy ) < shiftThresholdY )
		return

	lastPointerX = x
	lastPointerY = y

	if( shifting )
	{
		if( shiftDirection < 0 )
			shiftDirection = M.abs( dx ) > M.abs( dy )

		if( shiftDirection )
			shiftRowBy( shiftRow, dx )
		else
			shiftColBy( shiftCol, dy )
	}
	else if( dragging )
	{
		mapX += dx
		mapY += dy
	}
}

function startShift( x, y )
{
	var tile = tileAt( x-mapX, y-mapY )

	lastPointerX = x
	lastPointerY = y

	if( tile )
	{
		shiftCol = tile.col
		shiftRow = tile.row
		shiftDirection = -1
		shifting = true
	}
	else
		dragging = true
}

function pageXToGl( x )
{
	return (x-halfWidth)/halfWidth
}

function pageYToGl( y )
{
	return (halfHeight-y)/(halfHeight/yMax)
}

function setPointer( event, down )
{
	if( !down )
	{
		pointersLength = event.touches ?
			event.touches.length :
			0
	}
	else if( event.touches )
	{
		var touches = event.touches

		pointersLength = touches.length

		for( var n = pointersLength; n--; )
		{
			var t = touches[n]

			pointersX[n] = pageXToGl( t.pageX )
			pointersY[n] = pageYToGl( t.pageY )
		}
	}
	else
	{
		pointersLength = 1
		pointersX[0] = pageXToGl( event.pageX )
		pointersY[0] = pageYToGl( event.pageY )
	}

	event.preventDefault()
}

function pointerUp( event )
{
	stopShift()
	setPointer( event, false )
}

function pointerMove( event )
{
	setPointer( event, pointersLength )
	shift( pointersX[0], pointersY[0] )
}

function pointerDown( event )
{
	setPointer( event, true )

	if( pointersLength == 1 )
		startShift( pointersX[0], pointersY[0] )
}

function setKey( ev, pressed )
{
	var e = ev || event

// DEBUG START
	if( !pressed &&
		e.keyCode == 32 )
	{
		++level;
		loadLevel();
	}
// DEBUG STOP

	keysDown[e.keyCode] = pressed

	e.preventDefault()
	return false
}

function keyUp( ev )
{
	return setKey( ev, false )
}

function keyDown( ev )
{
	return setKey( ev, true )
}

function initTarget( cols, template )
{
	target = template
	targetLength = template.length
	targetCols = cols
}

function initMap( cols, rows, template )
{
	var offset = 0

	for( var r = 0, y = 0; r < rows; ++r, y -= tileSize )
		for( var c = 0, x = 0; c < cols; ++c, x += tileSize, ++offset )
		{
			var id = template[offset],
				tile = id < 1 ?
					{
						id: id,
						x: -2
					} :
					{
						id: id,
						x: x,
						y: y,
						toCol: c,
						toRow: r,
						col: c,
						row: r,
						sprite: sprites[id]
					}

			map[offset] = tile
		}

	mapLength = cols*rows
	mapX = (cols-1)/2*-tileSize
	mapY = -(rows-1)/2*-tileSize
	mapCols = cols
	mapRows = rows

	var wizard = 0
	for( var n = 0; n < mapLength; ++n )
		if( map[n].id > 0 )
		{
			wizard = n
			break
		}

	entities =
	[
		{
			sprite: sprites[WIZARD],
			tile: wizard
		},
	]
	entityLength = entities.length
}

function scale( sprite )
{
	var size = sprite.size*scaleFactor

	sprite.w = size
	sprite.h = size*sprite.ratio
}

function resize()
{
	canvas.width = width = W.innerWidth
	canvas.height = height = W.innerHeight

	halfWidth = width >> 1
	halfHeight = height >> 1
	yMax = height/width

	perspective = new Float32Array( [
		1, 0, 0,
		0, width/height, 0,
		0, 0, 1] )

	transformation = new Float32Array( [
		1, 0, 0,
		0, 1, 0,
		0, 0, 1] )

	gl.viewport( 0, 0, width, height )

	var ref = sprites[FLOOR].size
	scaleFactor = .5/halfWidth*M.ceil( M.min( width, height )/8/ref )
	tileSize = scaleFactor*2*ref
	halfTileSize = tileSize*.5
	horizonX = 1+tileSize/2
	horizonY = yMax+tileSize/2
	shiftThresholdX = .005
	shiftThresholdY = shiftThresholdX*yMax
	displaceSpeed = tileSize*.3

	var margin = tileSize*.4
	targetX = -1+margin
	targetY = yMax-margin
	targetTileSize = tileSize*.25
	targetFactor = targetTileSize/tileSize

	for( var id in sprites )
		scale( sprites[id] )

	loadLevel()
}

function cacheUniformLocations( program )
{
	if( program.uniforms === undefined )
		program.uniforms = {}

	var names = [
		PERSPECTIVE,
		TRANSFORMATION,
		TEXTURE,
	]

	for( var idx in names )
	{
		var name = names[idx]

		program.uniforms[name] =
			gl.getUniformLocation( program, name )
	}
}

function calculateSpriteRects()
{
	var res = [
			CBL, {/*tile_cbl*/x:2,y:759,w:32,h:32},
			CBLI, {/*tile_cbli*/x:38,y:758,w:32,h:32},
			CBR, {/*tile_cbr*/x:2,y:723,w:32,h:32},
			CBRI, {/*tile_cbri*/x:38,y:722,w:32,h:32},
			CTL, {/*tile_ctl*/x:2,y:687,w:32,h:32},
			CTLI, {/*tile_ctli*/x:38,y:686,w:32,h:32},
			CTR, {/*tile_ctr*/x:2,y:651,w:32,h:32},
			CTRI, {/*tile_ctri*/x:38,y:650,w:32,h:32},
			IC2B, {/*tile_ic2b*/x:2,y:615,w:32,h:32},
			IC2L, {/*tile_ic2l*/x:38,y:614,w:32,h:32},
			IC2R, {/*tile_ic2r*/x:2,y:579,w:32,h:32},
			IC2T, {/*tile_ic2t*/x:38,y:578,w:32,h:32},
			IC3BL, {/*tile_ic3bl*/x:2,y:543,w:32,h:32},
			IC3BR, {/*tile_ic3br*/x:38,y:542,w:32,h:32},
			IC3TL, {/*tile_ic3tl*/x:2,y:507,w:32,h:32},
			IC3TR, {/*tile_ic3tr*/x:38,y:506,w:32,h:32},
			IC4, {/*tile_ic4*/x:2,y:471,w:32,h:32},
			ICBL, {/*tile_icbl*/x:38,y:470,w:32,h:32},
			ICBR, {/*tile_icbr*/x:2,y:435,w:32,h:32},
			ICTL, {/*tile_ictl*/x:38,y:434,w:32,h:32},
			ICTR, {/*tile_ictr*/x:2,y:399,w:32,h:32},
			PH, {/*tile_ph*/x:38,y:398,w:32,h:32},
			PV, {/*tile_pv*/x:2,y:363,w:32,h:32},
			UB, {/*tile_ub*/x:38,y:362,w:32,h:32},
			UL, {/*tile_ul*/x:2,y:327,w:32,h:32},
			UR, {/*tile_ur*/x:38,y:326,w:32,h:32},
			UT, {/*tile_ut*/x:2,y:291,w:32,h:32},
			WB, {/*tile_wb*/x:38,y:290,w:32,h:32},
			WBIC2T, {/*tile_wbic2t*/x:2,y:255,w:32,h:32},
			WBICTL, {/*tile_wbictl*/x:38,y:254,w:32,h:32},
			WBICTR, {/*tile_wbictr*/x:2,y:219,w:32,h:32},
			WIZARD, {/*wizard*/x:2,y:795,w:13,h:16},
			WIZARD_CAST, {/*wizard_cast*/x:38,y:794,w:19,h:18},
			WL, {/*tile_wl*/x:38,y:218,w:32,h:32},
			WLIC2R, {/*tile_wlic2r*/x:2,y:183,w:32,h:32},
			WLICBR, {/*tile_wlicbr*/x:38,y:182,w:32,h:32},
			WLICTR, {/*tile_wlictr*/x:2,y:147,w:32,h:32},
			WR, {/*tile_wr*/x:38,y:146,w:32,h:32},
			WRIC2L, {/*tile_wric2l*/x:2,y:111,w:32,h:32},
			WRICBL, {/*tile_wricbl*/x:38,y:110,w:32,h:32},
			WRICTL, {/*tile_wrictl*/x:2,y:75,w:32,h:32},
			WT, {/*tile_wt*/x:38,y:74,w:32,h:32},
			WTIC2B, {/*tile_wtic2b*/x:2,y:39,w:32,h:32},
			WTICBL, {/*tile_wticbl*/x:38,y:38,w:32,h:32},
			WTICBR, {/*tile_wticbr*/x:38,y:2,w:32,h:32},
			FLOOR, {/*tile_floor*/x:2,y:2,w:32,h:33},
		],
		positions = [],
		xf = 1/atlas.width,
		yf = 1/atlas.height,
		index = 0

	for( var n = res.length; n > 0; )
	{
		var rc = res[--n],
			id = res[--n],
			x = rc.x,
			y = rc.y,
			w = rc.w,
			h = rc.h,
			l = xf*x,
			t = yf*y,
			r = xf*(x+w),
			b = yf*(y+h)

		sprites[id] = {
			index: index++,
			ratio: h/w,
			size: w }

		/* TRIANGLE_STRIP order:
		 *   A--C   A: x, y
		 *   | /|   B: x, y
		 *   |/ |   C: x, y
		 *   B--D   D: x, y */
		positions.push(
			l, t,
			l, b,
			r, t,
			r, b )
	}

	return positions
}

function initBuffers( program )
{
	vertexPositionBuffer = gl.createBuffer()
	gl.bindBuffer( gl.ARRAY_BUFFER, vertexPositionBuffer )
	gl.bufferData( gl.ARRAY_BUFFER,
		new Float32Array( [
			-1, 1,
			-1, -1,
			1, 1,
			1, -1] ),
		gl.STATIC_DRAW )

	vertexPositionLoc = gl.getAttribLocation(
		program,
		"vertexPosition" )
	gl.enableVertexAttribArray( vertexPositionLoc )

	texturePositionBuffer = gl.createBuffer()
	gl.bindBuffer( gl.ARRAY_BUFFER, texturePositionBuffer )
	gl.bufferData(
		gl.ARRAY_BUFFER,
		new Float32Array( calculateSpriteRects() ),
		gl.STATIC_DRAW )

	texturePositionLoc = gl.getAttribLocation(
		program,
		"texturePosition" )
	gl.enableVertexAttribArray( texturePositionLoc )
}

function createTextureFrom( image )
{
	var t = gl.createTexture()

	if( t < 1 )
		return

	gl.bindTexture( gl.TEXTURE_2D, t )

	gl.texImage2D(
		gl.TEXTURE_2D,
		0,
		gl.RGBA,
		gl.RGBA,
		gl.UNSIGNED_BYTE,
		image )

	gl.texParameteri(
		gl.TEXTURE_2D,
		gl.TEXTURE_MIN_FILTER,
		gl.NEAREST )
	gl.texParameteri(
		gl.TEXTURE_2D,
		gl.TEXTURE_MAG_FILTER,
		gl.NEAREST )
	gl.texParameteri(
		gl.TEXTURE_2D,
		gl.TEXTURE_WRAP_S,
		gl.CLAMP_TO_EDGE )
	gl.texParameteri(
		gl.TEXTURE_2D,
		gl.TEXTURE_WRAP_T,
		gl.CLAMP_TO_EDGE )

	gl.generateMipmap( gl.TEXTURE_2D )
	gl.bindTexture( gl.TEXTURE_2D, null )

	return t
}

function compileShader( src, type )
{
	var shader = gl.createShader( type )

	gl.shaderSource( shader, src )
	gl.compileShader( shader )

	return gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ?
		shader :
		null
}

function linkProgram( vs, fs )
{
	var p

	if( (p = gl.createProgram()) )
	{
		gl.attachShader( p, vs )
		gl.attachShader( p, fs )

		gl.linkProgram( p )

		if( !gl.getProgramParameter( p, gl.LINK_STATUS ) )
		{
			gl.deleteProgram( p )
			p = null
		}
	}

	return p
}

function buildProgram( vertexSource, fragmentSource )
{
	var p,
		vs,
		fs

	if( (vs = compileShader(
		vertexSource,
		gl.VERTEX_SHADER )) )
	{
		if( (fs = compileShader(
			fragmentSource,
			gl.FRAGMENT_SHADER )) )
		{
			p = linkProgram( vs, fs )

			gl.deleteShader( fs )
		}

		gl.deleteShader( vs )
	}

	return p
}

function init()
{
	if( !(canvas = D.getElementById( "Canvas" )) ||
		(
			!(gl = canvas.getContext( "webgl" )) &&
			!(gl = canvas.getContext( "experimental-webgl" ))
		) ||
		!(program = buildProgram(
			D.getElementById( "VertexShader" ).textContent,
			D.getElementById( "FragmentShader" ).textContent )) ||
		!(texture = createTextureFrom( atlas )) )
	{
		D.write( "Sorry, your browser cannot render this content." )
		return
	}

	gl.enable( gl.BLEND )
	gl.blendFunc( gl.ONE, gl.ONE_MINUS_SRC_ALPHA )
	gl.clearColor( .15, .15, .15, 1 )

	initBuffers( program )
	cacheUniformLocations( program )

	W.onresize = resize
	resize()

	D.onkeydown = keyDown
	D.onkeyup = keyUp

	D.onmousedown = pointerDown
	D.onmousemove = pointerMove
	D.onmouseup = pointerUp
	D.onmouseout = pointerUp

	if( "ontouchstart" in D )
	{
		D.ontouchstart = pointerDown
		D.ontouchmove = pointerMove
		D.ontouchend = pointerUp
		D.ontouchleave = pointerUp
		D.ontouchcancel = pointerUp
	}

	last = Date.now()-16
	run()
}

function load()
{
	atlas = new Image()
	atlas.src = "atlas.png"
	atlas.onload = init
}

W.onload = load

</script>
</body>
</html>
